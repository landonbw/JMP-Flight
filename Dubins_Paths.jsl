///////////////////////////////////////////////////////////////////////////////////////////
//	Find Dubins Parameters
///////////////////////////////////////////////////////////////////////////////////////////
rotate_z = Function( {rot_z_theta},
	rot_z_out = matrix({{cos(rot_z_theta), -sin(rot_z_theta), 0},
						{sin(rot_z_theta), cos(rot_z_theta), 0},
						{0,          0,          1}})
);

mod_2_pi = Function( {mod_theta},
	mod_ret = mod(mod_theta, 2 * pi());
);


vec_mag = Function( {mag_x},
	sqrt(mag_x`*mag_x)[1];
);

min_val = Function( {min_numbers},
	// loop through list to find the minimum value
	minimum_value = min_numbers[1];
	For(i = 1, i <= length(min_numbers), i += 1,
		if(eval(min_numbers[i]) < minimum_value,
			minimum_value = min_numbers[i]
		);
	);
	minimum_value;
);

/// takes the start and exit positions and calculates the distances of the paths
/// between them
find_dubins_parameters = Function( {dub_pos_s, dub_course_s, dub_pos_e, dub_course_e, dub_rad},
	// require that the distance between the points is at least three times
	// the turning radius
	dub_point_dist = sqrt((dub_pos_s[1]-dub_pos_e[1])^2 + (dub_pos_s[2]-dub_pos_e[2])^2 + (dub_pos_s[3]-dub_pos_e[3])^2);
	
	dub_e1 = matrix({1, 0, 0});
	
	if(dub_point_dist < 3*dub_rad, is_valid = 0, is_valid = 1);
	
	
	
	// calculate the centers of the turning circles
	dub_c_r_s = dub_pos_s + dub_rad * rotate_z((pi()/2)) * matrix({cos(dub_course_s), sin(dub_course_s), 0});
	dub_c_l_s = dub_pos_s + dub_rad * rotate_z((-pi()/2)) * matrix({cos(dub_course_s), sin(dub_course_s), 0});
	dub_c_r_e = dub_pos_e + dub_rad * rotate_z((pi()/2)) * matrix({cos(dub_course_e), sin(dub_course_e), 0});
	dub_c_l_e = dub_pos_e + dub_rad * rotate_z((-pi()/2)) * matrix({cos(dub_course_e), sin(dub_course_e), 0});
	show(dub_c_r_s, dub_c_l_s, dub_c_r_e, dub_c_l_e);
		
	// calculate the lengths of each possible dubins path
	
	// calculate the length of R-S-R
	dub_ang = atan(dub_c_r_e[2] - dub_c_r_s[2], dub_c_r_e[1] - dub_c_r_s[1]);
	dub_l1 = vec_mag(dub_c_r_s - dub_c_r_e) + dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_ang - pi()/2) - mod_2_pi(dub_course_s - pi()/2))
			+ dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_course_e - pi()/2) - mod_2_pi(dub_ang - pi()/2));
	show(dub_l1);
			
	// calculate the length of R-S-L
	dub_ang = atan(dub_c_r_e[2] - dub_c_r_s[2], dub_c_r_e[1] - dub_c_r_s[1]);
	small_l = vec_mag(dub_c_l_e - dub_c_r_s);
	dub_ang2 = dub_ang - pi()/2 + arcsine((2 * dub_rad) / small_l);
	dub_l2 = sqrt(small_l^2 - (2 * dub_rad^2)) + dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_ang2) - mod_2_pi(dub_course_s - pi()/2))
			+ dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_ang2 + pi()) - mod_2_pi(dub_course_e + Pi()/2));
	show(dub_l2);
	
	// calculate the length of L-S-R
	dub_ang = atan(dub_c_r_e[2] - dub_c_r_s[2], dub_c_r_e[1] - dub_c_r_s[1]);
	small_l = vec_mag(dub_c_r_e - dub_c_l_s);
	dub_ang2 = arccosine(2*dub_rad / small_l);
	dub_l3 = sqrt(small_l^2 - (2 * dub_rad^2)) + dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_course_s + pi() / 2) - mod_2_pi(dub_ang + dub_ang2))
			+ dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_course_e - pi()/2) - mod_2_pi(dub_ang + dub_ang2 - pi()));
	show(dub_l3);
			
	// calculate the length of L-S-L
	dub_ang = atan(dub_c_l_e[2] - dub_c_l_s[2], dub_c_l_e[1] - dub_c_l_s[1]);
	dub_l4 = vec_mag(dub_c_l_s - dub_c_l_e) + dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_course_s + pi()/2) - mod_2_pi(dub_ang + pi()/2))
			+ dub_rad * mod_2_pi(2 * pi() + mod_2_pi(dub_ang + pi()/2) - mod_2_pi(dub_course_e + pi()/2));
	show(dub_l4);
			
	// find the shortest path
	dub_min_length = min_val({dub_l1, dub_l2, dub_l3, dub_l4});
	
	// assign the output values corresponding to the shortest path
	if(dub_min_length == dub_l1,
		dub_cs = dub_c_r_s;
		dub_lam_s = 1;
		dub_ce = dub_c_r_e;
		dub_lam_e = 1;
		dub_q1 = (dub_ce - dub_cs) / vec_mag(dub_ce - dub_cs);
		dub_z1 = dub_cs + dub_rad * Multiply(rotate_z(-pi()/2), dub_q1);
		dub_z2 = dub_ce + dub_rad * Multiply(rotate_z(-pi()/2), dub_q1);,
		// if else
		dub_min_length == dub_l2,
		dub_cs = dub_c_r_s;
		dub_lam_s = 1;
		dub_ce = dub_c_l_e;
		dub_lam_e = -1;
		small_l = vec_mag(dub_ce - dub_cs);
		dub_ang = atan(dub_ce[2] - dub_cs[2], dub_ce[1] - dub_cs[1]);
		dub_ang2 = dub_ang - pi()/2 + arcsine((2 * dub_rad) / small_l);
		dub_q1 = Multiply(rotate_z(dub_ang2), dub_e1);
		dub_z1 = dub_cs + dub_rad * Multiply(rotate_z(dub_ang2), dub_e1);
		dub_z2 = dub_ce + dub_rad * Multiply(rotate_z(dub_ang2 + pi()), dub_e1);,
		// if else
		dub_min_length == dub_l3,
		dub_cs = dub_c_l_s;
		dub_lam_s = -1;
		dub_ce = dub_c_r_e;
		dub_lam_e = 1;
		small_l = vec_mag(dub_ce - dub_cs);
		dub_ang = atan(dub_ce[2] - dub_cs[2], dub_ce[1] - dub_cs[1]);
		dub_ang2 = arccosine((2 * dub_rad) / small_l);
		dub_q1 = Multiply(rotate_z(dub_ang + dub_ang_2 - pi()/2), dub_e1);
		dub_z1 = dub_cs + dub_rad * Multiply(rotate_z(dub_ang + dub_ang2), dub_e1);
		dub_z2 = dub_ce + dub_rad * Multiply(rotate_z(dub_ang + dub_ang2 - pi()), dub_e1);,
		// else case (case 4 L-S-L) 
		// dub_min_length == dub_l4
		dub_cs = dub_c_l_s;
		dub_lam_s = -1;
		dub_ce = dub_c_l_e;
		dub_lam_e = -1;
		dub_q1 = (dub_ce - dub_cs) / vec_mag(dub_ce - dub_cs);
		dub_z1 = dub_cs + dub_rad * Multiply(rotate_z(pi()/2), dub_q1);
		dub_z2 = dub_ce + dub_rad * Multiply(rotate_z(pi()/2), dub_q1);
	);
	
	dub_z3 = dub_pos_e;
	dub_q3 = Multiply(rotate_z(dub_course_e), dub_e1);
	// return the right data (silly jmp with no returns)
	dub_output = list(dub_min_length, dub_cs, dub_lam_s, dub_ce, dub_lam_e, dub_z1, dub_q1, dub_z2, dub_z3, dub_q3);
);

get_dubins_points = Function({dub_points_params, dub_p_start, dub_p_end},
	// upack the points params
	dub_p_L = eval(dub_points_params[1]);
	dub_p_cs = eval(dub_points_params[2]);
	dub_p_lam_s = eval(dub_points_params[3]);
	dub_p_ce = eval(dub_points_params[4]);
	dub_p_lam_e = eval(dub_points_params[5]);
	dub_p_z1 = eval(dub_points_params[6]);
	dub_p_q1 = eval(dub_points_params[7]);
	dub_p_z2 = eval(dub_points_params[8]);
	dub_p_z3 = eval(dub_points_params[9]);
	dub_p_q3 = eval(dub_points_params[10]);
	
	// find points around the first circle
	dub_p_rad = vec_mag(dub_p_cs - dub_p_start);
	dub_p_start_ang = atan(dub_p_start[2] - dub_p_cs[2], dub_p_start[1] - dub_p_cs[1]);
	dub_p_end_ang = atan(dub_p_z1[2] - dub_p_cs[2], dub_p_z1[1] - dub_p_cs[1]);
	dub_p_theta_step = 0.001;
	dub_p_theta_travel = abs(dub_p_start_ang - dub_p_end_ang);
	dub_p_num_steps = floor(dub_p_theta_travel / dub_p_theta_step);
	// get the points
	dub_p_points = J(dub_p_num_steps, 3);
	for(dub_p_i=1, dub_p_i<=dub_p_num_steps, dub_p_i++,
		dub_p_points[dub_p_i, 1] = dub_p_cs[1] + dub_p_rad * cos(dub_p_start_ang + dub_p_i * dub_p_theta_step * dub_p_lam_s);
		dub_p_points[dub_p_i, 2] = dub_p_cs[2] + dub_p_rad * sin(dub_p_start_ang + dub_p_i * dub_p_theta_step * dub_p_lam_s);
		dub_p_points[dub_p_i, 3] = dub_p_cs[3];
	);
	
	// find points along the line
	//z1 to z2
	dub_p_q = (dub_p_z2 - dub_p_z1);
	dub_p_sl = vec_mag(dub_p_q);
	dub_p_q = dub_p_q/dub_p_sl;
	dub_p_delta = 0.01;
	dub_p_num_steps = dub_p_sl / dub_p_delta;
	dub_p_points2 = J(dub_p_num_steps, 3);
	// get the points
	for(dub_p_i=1, dub_p_i<=dub_p_num_steps, dub_p_i++,
		dub_p_points2[dub_p_i,1] = dub_p_z1[1] + dub_p_i * dub_p_delta * dub_p_q[1];
		dub_p_points2[dub_p_i,2] = dub_p_z1[2] + dub_p_i * dub_p_delta * dub_p_q[2];
		dub_p_points2[dub_p_i,3] = dub_p_z1[3];
	);
	dub_p_points = dub_p_points |/ dub_p_points2; 
	
	// find points along the end circle
	dub_p_start_ang = atan(dub_p_z2[2] - dub_p_ce[2], dub_p_z2[1] - dub_p_ce[1]);
	dub_p_end_ang = atan(dub_p_z3[2] - dub_p_ce[2], dub_p_z3[1] - dub_p_ce[1]);
	dub_p_theta_step = 0.001;
	dub_p_theta_travel = abs(dub_p_start_ang - dub_p_end_ang);
	dub_p_num_steps = floor(dub_p_theta_travel / dub_p_theta_step);
	// get the points
	dub_p_points2 = J(dub_p_num_steps, 3);
	for(dub_p_i=1, dub_p_i<=dub_p_num_steps, dub_p_i++,
		dub_p_points2[dub_p_i, 1] = dub_p_ce[1] + dub_p_rad * cos(dub_p_start_ang + dub_p_i * dub_p_theta_step * dub_p_lam_e);
		dub_p_points2[dub_p_i, 2] = dub_p_ce[2] + dub_p_rad * sin(dub_p_start_ang + dub_p_i * dub_p_theta_step * dub_p_lam_e);
		dub_p_points2[dub_p_i, 3] = dub_p_ce[3];
	);
	dub_p_points = dub_p_points |/ dub_p_points2;
	
	as table(dub_p_points);
);

//dub_pos_s, dub_course_s, dub_pos_e, dub_rad

a = find_dubins_parameters(matrix({0,0,3}), pi()/2, matrix({100,0,3}), 3*pi()/2, 10);
b = get_dubins_points(a, matrix({0,0,3}), matrix({100,0,3}));


//show(eval(a[1]));
//show(eval(a[2]));
//show(eval(a[3]));
//show(eval(a[4]));
//show(eval(a[5]));
//show(eval(a[6]));
//show(eval(a[7]));
//show(eval(a[8]));
//show(eval(a[9]));
//show(eval(a[10]));

