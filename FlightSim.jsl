clear globals();
clear log();

initStates_expr = expr(

///////////////////////////////////////////////////////////////////////////////////////////
					//	State Params
///////////////////////////////////////////////////////////////////////////////////////////


aircraftState = [0, 0, -200, 34.99979, 0, 0.1192, 0, 0, 0, 0, 0, 0];

Pn = 0.0;
Pe = 0.0;
Pd = -20.0;
u = 3.49997970e+01;
v = -2.76273829e-05;
w = 1.19203683e-01;
phi = -1.52263833e-06;
theta =  3.40582609e-03;
psi = 0.0;

p = 0;
q = 0;
r = 0;

fx = 0.0;
fy = 0.0;
fz = 0.0;
ml = 0.0;
mm = 0.0;
mn = 0.0;

deltaA = 0.0;
deltaE = -0.049348;
deltaR = 0.0;
deltaT = 0.46382;

///////////////////////////////////////////////////////////////////////////////////////////
					//	Plane Parameters
///////////////////////////////////////////////////////////////////////////////////////////
mass = 13.5; //kg
jx = 0.8244;//kg m^2
jy = 1.135;
jz = 1.759;
jxz = 0.1204;

S = 0.55;
b = 2.8956;
c = 0.18994;
Sprop = 0.2027;
rho = 1.2682;
kMotor = 80;
kTp = 0.0;
kOmega = 0.0;
e = 0.9;
AR = (b^2) / S;

g = 9.8;    //gravity

///////////////////////////////////////////////////////////////////////////////////////////
                //   Longitudinal Coefficients
///////////////////////////////////////////////////////////////////////////////////////////
CL0 = 0.28;
Cd0 = 0.03;
Cm0 = -0.02338;
ClAlpha = 3.45;
CdAlpha = 0.3;
CmAlpha = -0.38;
Clq = 0.0;
Cdq = 0.0;
Cmq = -3.6;
ClDeltae = -0.36;
CdDeltae = 0.0;
CmDeltae = -0.5;
Cprop = 1.0;
M = 50.0;
alpha0 = 0.4712;
epsilon = 0.1592;
Cdp = 0.0437;

///////////////////////////////////////////////////////////////////////////////////////////
                //   Lateral Coefficients
///////////////////////////////////////////////////////////////////////////////////////////
Cy0 = 0.0;
Cl0 = 0.0;
Cn0 = 0.0;
CyBeta = -0.98;
ClBeta = -0.12;
CnBeta = 0.25;
CyP = 0.0;
ClP = -0.26;
CnP = 0.022;
CYr = 0.0;
Clr = 0.14;
Cnr = -0.35;
CyDeltaa = 0.0;
ClDeltaa = 0.08;
CnDeltaa = 0.06;
CyDeltar = -0.17;
ClDeltar = 0.105;
CnDeltar = -0.032;

///////////////////////////////////////////////////////////////////////////////////////////
                //	Calculation Values
///////////////////////////////////////////////////////////////////////////////////////////
ts_simulation = 0.10;
num_steps = 10;
//   gamma parameters pulled from page 36 (dynamics)
gamma = jx * jz - (jxz^2);
gamma1 = (jxz * (jx - jy + jz)) / gamma;
gamma2 = (jz * (jz - jy) + (jxz^2)) / gamma;
gamma3 = jz / gamma;
gamma4 = jxz / gamma;
gamma5 = (jz - jx) / jy;
gamma6 = jxz / jy;
gamma7 = ((jx - jy) * jx + (jxz^2)) / gamma;
gamma8 = jx / gamma;

//   C values defines on pag 62
Cp0         = gamma3 * Cl0      + gamma4 * Cn0;
CpBeta      = gamma3 * ClBeta   + gamma4 * CnBeta;
CpP         = gamma3 * ClP      + gamma4 * CnP;
CpR         = gamma3 * Clr      + gamma4 * Cnr;
CpDeltaA    = gamma3 * ClDeltaa + gamma4 * CnDeltaa;
CpDeltaR    = gamma3 * ClDeltar + gamma4 * CnDeltar;
Cr0         = gamma4 * Cl0      + gamma8 * Cn0;
CrBeta      = gamma4 * ClBeta   + gamma8 * CnBeta;
CrP         = gamma4 * ClP      + gamma8 * CnP;
CrR         = gamma4 * Clr      + gamma8 * Cnr;
CrDeltaA    = gamma4 * ClDeltaa + gamma8 * CnDeltaa;
CrDeltaR    = gamma4 * ClDeltar + gamma8 * CnDeltar;

///////////////////////////////////////////////////////////////////////////////////////////
                //	Slider Params
///////////////////////////////////////////////////////////////////////////////////////////

x_coor = [0];
y_coor = [0];

vec_x = [1];
vec_y = [1];
vec_z = [1];

angleperspective = 45;
nearperspective = 1;
farperspective = 200;

translateto_x_val = 0;
translateto_y_val = -5;
translateto_z_val = -26;

lookat_x_val = 0;
lookat_y_val = 60;
lookat_z_val = 20;

moveto_x_val = 0;
moveto_y_val = 0;
moveto_z_val = 4;

rotateto_x_val = 0;
rotateto_y_val = 180;
rotateto_z_val = 0;

rotateACto_x_val = 0;
rotateACto_y_val = 180;
rotateACto_z_val = 180;

centerpoint_x_val = 0;
centerpoint_y_val = 0;
centerpoint_z_val = 6;
);

Include("simpleairplaneparts.jsl");
drawtheairplane_expr = expr(

plane = SceneDisplayList(1);
/*
plane << pushmatrix;
   plane  << Enable(Lighting); 
   plane  << Enable(Light0); 
   plane  << Light(Light0,AMBIENT,LightAmbient1,LightAmbient2,LightAmbient3,LightAmbient4);  
   plane  << Light(Light0,DIFFUSE,LightDiffuse1,LightDiffuse2,LightDiffuse3,LightDiffuse4);  
   plane  << Light(Light0,SPECULAR,LightSpecular1,LightSpecular2,LightSpecular3,LightSpecular4);  
   plane  << LightModel( LIGHT_MODEL_AMBIENT, LightModelAmbient1, LightModelAmbient2, LightModelAmbient3, LightModelAmbient4 );
   plane  << Material(Front,Ambient,MaterialAmbient1,MaterialAmbient2,MaterialAmbient3,MaterialAmbient4);
   plane  << Material(Front,Diffuse,MaterialDiffuse1,MaterialDiffuse2,MaterialDiffuse3,MaterialDiffuse4);
   plane  << Material(Front,Specular,MaterialSpecular1,MaterialSpecular2,MaterialSpecular3,MaterialSpecular4);
   plane  << Material(Front,Emission,MaterialEmission1,MaterialEmission2,MaterialEmission3,MaterialEmission4);
   plane  << Material(Front,Shininess,MaterialShininess);
plane << popmatrix;*/




//plane << sphere(0.1,30,30);
plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(nose);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(tail);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(body1);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(body2);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(leftwingtip);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(rightwingtip);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(leftwing);
plane << popmatrix;

plane << pushmatrix;
//plane << translate( -2,-1,0 );
plane << call list(rightwing);
plane << popmatrix;

plane << pushmatrix;
plane << translate(2, 0, -.5);
plane << Rotate(-deltaA*180/3.14159,1,0,0);
plane << call list(leftflap);
plane << popmatrix;

plane << pushmatrix;
plane << translate(-2, 0, -.5);
plane << Rotate(deltaA*180/3.14159,1,0,0);
plane << call list(rightflap);
plane << popmatrix;

plane << pushmatrix;
plane << call list(tailwing);
plane << popmatrix;

plane << pushmatrix;
//tailwing << translate( 0, 0, -4.5 );
plane << translate (0, 0, -4.5);
plane << Rotate( deltaR*180/3.14159, 0, 1, 0 );
plane << call list(rudder);
plane << popmatrix;

plane << pushmatrix;
//Enable(POLYGON_OFFSET_LINE);
//Polygon Offset(1,1);
plane << call list(cockpit);
plane << popmatrix;

//plane << Enable(POLYGON_OFFSET_LINE);
//plane << Polygon Offset(1,1);
/*plane << Color( 0.5, 0, 0 );
plane << pushmatrix;
plane<<Enable(Lighting);
plane<<Enable(Light0);
plane<<Light(Light0,POSITION,10,10,10,1); //near viewer
scene<<Light(Light0,DIFFUSE,.5,.5,1,1); //blue-gray light
plane << popmatrix;*/

);

listofblocks_x = J(1,150,Random Integer(300)-150);
listofblocks_y = J(1,150,Random Integer(2000)-1000);
listofblocks_z = J(1,150,Random Integer(100));
listofblockdims_x = J(1,150,Random Integer(50));
listofblockdims_y = J(1,150,Random Integer(50));
listofblockdims_z = J(1,150,Random Integer(50));

makethebox_expr = expr(
box = Scene Display List( 1 );
//box << PolygonMode(FRONT_AND_BACK, LINE);


for(i=1, i<80, i++,
	//moveto_x_val = listofmoves_x[i];
	//moveto_y_val = listofmoves_y[i];
	blockdim_x = listofblockdims_x[i];
	blockdim_y = listofblockdims_y[i];
	blockdim_z = listofblockdims_z[i];

	box << pushmatrix;
	box << Translate(listofblocks_x[i+60],listofblocks_y[i+60],listofblocks_z[i+60]);
	box << Color(0.9,0.9,0.9);
	box << sphere(listofblocks_z[i]/10, 20, 20);
	box << popmatrix;
	
	box << pushmatrix;
	box << Translate(listofblocks_y[i+60],listofblocks_x[i+60],listofblocks_z[i+60]);
	box << Rotate(90,1,0,0);
	box << Color(0.9,0.9,0.9);
	//box << sphere(listofblocks_z[i]/10, 20, 20);
	box << disk(listofblocks_z[i]/10, 20, 20,20);
	box << popmatrix;
	
	box << pushmatrix;
	//box << Translate(lookat_x_val,lookat_y_val,lookat_z_val);
	box << Translate(listofblocks_x[i],listofblocks_y[i],1);
	box << linewidth(2);
	box << Begin( QUADS );
	box << Color(0.7,0.7,0.7);
	box<<Vertex(0, 0, 0);
	box<<Vertex(0, 0, blockdim_z);
	box<<Vertex(0, blockdim_y, blockdim_z);
	box<<Vertex(0, blockdim_y, 0);
	
	box<<Vertex(blockdim_x, 0, 0);
	box<<Vertex(blockdim_x, 0, blockdim_z);
	box<<Vertex(blockdim_x, blockdim_y, blockdim_z);
	box<<Vertex(blockdim_x, blockdim_y, 0);
	
	box << Color(0.3,0.3,0.3);
	box<<Vertex(0,	0, 0);
	box<<Vertex(blockdim_x,	0, 0);
	box<<Vertex(blockdim_x,	0, blockdim_z);
	box<<Vertex(0,	0, blockdim_z);
	
	box<<Vertex(0,	blockdim_y, 0);
	box<<Vertex(blockdim_x,	blockdim_y, 0);
	box<<Vertex(blockdim_x,	blockdim_y, blockdim_z);
	box<<Vertex(0,	blockdim_y, blockdim_z);
	
	
	
	box << Color(0.5,0.5,0.5);
	box<<Vertex(0,0,	0);
	box<<Vertex(0,blockdim_y,	0);
	box<<Vertex(blockdim_x,blockdim_y,	0);
	box<<Vertex(blockdim_x,0,	0);
	
	box<<Vertex(0,0,	blockdim_z);
	box<<Vertex(0,blockdim_y,	blockdim_z);
	box<<Vertex(blockdim_x,blockdim_y,	blockdim_z);
	box<<Vertex(blockdim_x,0,	blockdim_z);
	box<<End();
	box << popmatrix;

);

box << Color(0.4,1,0.4);
box << Begin( QUADS );
box<<Vertex(-1000, -1000, 0);
box<<Vertex(1000, -1000, 0);
box<<Vertex(1000, 1000, 0);
box<<Vertex(-1000, 1000, 0);
box<<End();

box << Color(1,0,0);
box<<sphere(0.1, 20, 20);

box << pushmatrix;
box << translate(-1, -6, 0);
box<<sphere(0.1, 20, 20);
box << popmatrix;
);


///////////////////////////////////////////////////////////////////////////////////////////
                //   calculate the changeing parameters to determine the forces
///////////////////////////////////////////////////////////////////////////////////////////
cl_alpha = function({alpha},
	ret_cl = CL0 + ClAlpha * alpha;
	return(ret_cl);
);

cd_alpha = function({alpha},
	ret_cd = Cd0 + CdAlpha * alpha;
	return(ret_cd);
);

cx_alpha = function({alpha},
	ret_cx = -cdAlpha(alpha) * cos(alpha) + clAlpha(alpha) * sin(alpha);
	return(ret_cx);
);

cx_q = function({alpha},
	ret_cxq = -Cdq * cos(alpha) + Clq * sin(alpha);
	return(ret_cxq);
);

cx_del_e = function({alpha},
	ret_cxdel = -CdDeltae * cos(alpha) + ClDeltae * sin(alpha);
	return(ret_cxdel);
);

cz_alpha = function({alpha},
	ret_cz = -cd_Alpha(alpha) * sin(alpha) - cl_Alpha(alpha) * cos(alpha);
	return(ret_cz);
);

cz_q = function({alpha},
	ret_czq = -Cdq * sin(alpha) - Clq * cos(alpha);
	return(ret_czq);
);

cz_del_e = function({alpha},
	ret_czdel = -CdDeltae * sin(alpha) - ClDeltae * cos(alpha);
);


///////////////////////////////////////////////////////////////////////////////////////////
                //   Calculate forces on the airframe
///////////////////////////////////////////////////////////////////////////////////////////
getForces_expr = expr(
	va = sqrt(u^2 + v^2 + w^2);
	alpha = ArcTan(w/u);
	beta = ArcSine(v/va);
	show(va);
	show(alpha);
	show(beta);
	fx = -mass*g*sin(theta) + 0.5 * rho * va^2 * S * (cx_alpha(alpha) + cx_q(alpha) * (c * q / (2 * va)) + cx_del_e(alpha) * deltaE) + 0.5 * rho * Sprop * Cprop * ((kMotor*deltaT)^2 - va^2);
	fy = mass * g * cos(theta) * sin(phi) + 0.5 * rho * va^2 * S * (Cy0 + CyBeta * beta + CyP * (b*p/(2*va)) + CYr * (b*r/(2*va)) + Cydeltaa * deltaA + CyDeltar * DeltaR);
	fz = mass * g * cos(theta) * cos(phi) + 0.5 * rho * va^2 * S * (cz_alpha(alpha) + cz_q(alpha) * c * q /(2 * va) + cz_del_e(alpha) * deltaE);
	ml = 0.5 * rho * va^2 * S * b * (CL0 * ClBeta * beta + ClP * b * p / (2 * va) + Clr * b * r / (2 * va) + ClDeltaa * deltaA + ClDeltar * deltaR);
	mm = 0.5 * rho * va^2 * S * c * (Cm0 + CmAlpha * alpha + Cmq * c * q / (2 * va) + CmDeltae * deltaE);
	mn = 0.5 * rho * va^2 * S * b * (Cn0 + CnBeta * beta + CnP * b * p / (2 * va) + Cnr * b * r / (2 * va) + CnDeltaa * deltaA + CnDeltaR * deltaR);
	show(deltaA);
);

derivatives = function({state, inputs},
	pn = state[1];
	pe = state[2];
	pd = state[3];
	u = state[4];
	v = state[5];
	w = state[6];
	phi = state[7];
	theta = state[8];
	psi = state[9];
	p = state[10];
	q = state[11];
	r = state[12];
	
	fx = inputs[1];
	fy = inputs[2];
	fz = inputs[3];
	l = inputs[4];
	m = inputs[5];
	n = inputs[6];
	
	cphi = cos(phi);
	sphi = sin(phi);
	ctheta = cos(theta);
	stheta = sin(theta);
	ttheta = tan(theta);
	cpsi = cos(psi);
	spsi = sin(psi);
	
	pn_dot = ctheta * cpsi * u + (sphi * stheta * cpsi - cphi * spsi) * v + (cphi * stheta * cpsi + sphi * spsi) * w;
	pe_dot = ctheta * spsi * u + (sphi * stheta * spsi + cphi * cpsi) * v + (cphi * stheta * sphi - sphi * cpsi) * w;
	pd_dot = -stheta * u + sphi * ctheta * v + cphi * ctheta * w;
	
	u_dot = r * v - q * w + fx / mass;
	v_dot = p * w - r * w + fy / mass;
	w_dot = q * u - P * v + fz / mass;
	
	phi_dot = p + sphi * ttheta * q + cphi * ttheta * r;
	theta_dot = cphi * q - sphi * r;
	psi_dot = sphi * q / ctheta + cphi * r / ctheta;
	
	p_dot = gamma1 * p * q - gamma2 * q * r + gamma3 * l + gamma4 * n;
	q_dot = gamma5 * p * r - gamma6 * (p^2 - r*2) + m / jy;
	r_dot = gamma7 * p * q - gamma1 * q * r + gamma4 * l + gamma8 * n;
	
	
	edgkrsh = matrix({pn_dot, pe_dot, pd_dot, u_dot, v_dot, w_dot, phi_dot, theta_dot, psi_dot, p_dot, q_dot, r_dot});
	return(edgkrsh);
	
);

updateState_expr = expr(
	current_state = matrix({pn, pe, pd, u, v, w, phi, theta, psi, p, q, r});
	current_inputs = matrix({fx, fy, fz, ml, mm, mn});
	k1 = derivatives(current_state, current_inputs);
	show(current_state * ts_simulation / num_steps / 2 :* k1, current_inputs);
	k2 = derivatives(current_state * ts_simulation / num_steps / 2 :* k1, current_inputs);
	k3 = derivatives(current_state * ts_simulation / num_steps / 2 :* k2, current_inputs);
	k4 = derivatives(current_state * ts_simulation / num_steps :* k3, current_inputs);
	new_state = current_state + (ts_simulation / num_steps / 6) * (k1 + 2 * k2 + 2 * k3 + k4);
	
	show(new_state);
	
	pn = new_state[1];
	pe = new_state[2];
	pd = new_state[3];
	u = new_state[4];
	v = new_state[5];
	w = new_state[6];
	phi = new_state[7];
	theta = new_state[8];
	psi = new_state[9];
	p = new_state[10];
	q = new_state[11];
	r = new_state[12];
);








get_lateral_control_expr = expr(
	
);



nw = New Window( "Test Window",
	hlistbox(
		ob_test = outlinebox("My outline box",
			scene = SceneBox(1000,700),
			hlistbox(textbox("perspective Angle"),sb_perspective = sliderbox(15,180,angleperspective,draw_world)),
			hlistbox(textbox("near limit"), sb_perspective_near = sliderbox(2,18,nearperspective,draw_world)),
			hlistbox(textbox("far limit"), sb_perspective_far = sliderbox(0,2000,farperspective,draw_world)),
			hlistbox(textbox("Look From X"), sb_lookat_x = sliderbox(-200,200,lookat_x_val,draw_world)),
			hlistbox(textbox("Look From Y"), sb_lookat_y = sliderbox(-200,200,lookat_y_val,draw_world)),
			hlistbox(textbox("Look From Z"), sb_lookat_z = sliderbox(0,200,lookat_z_val,draw_world)),
			hlistbox(textbox("Center Point X"), sb_centerpoint_x = sliderbox(-200,200,centerpoint_x_val,draw_world)),
			hlistbox(textbox("Center Point Y"), sb_centerpoint_y = sliderbox(-200,200,centerpoint_y_val,draw_world)),
			hlistbox(textbox("Center Point Z"), sb_centerpoint_z = sliderbox(0,200,centerpoint_z_val,draw_world)),
			
			hlistbox(textbox("Aileron Control"), sb_aileron = sliderbox(-0.52, 0.52, deltaA, getForces_expr)),
			hlistbox(textbox("Elevator Control"), sb_elevator = sliderbox(-0.52, 0.52, deltaE, getForces_expr)),
			hlistbox(textbox("Rudder Control"), sb_rudder = sliderbox(-0.52, 0.52, deltaR, getForces_expr)),
			hlistbox(textbox("Throttle Control"), sb_throttle = sliderbox(0, 1, deltaT, getForces_expr)),
			
			hlistbox(textbox("PN"), sb_aileron = sliderbox(-500, 500, Pn, getForces_expr)),
			hlistbox(textbox("PE"), sb_elevator = sliderbox(-500, 500, Pe, getForces_expr)),
			hlistbox(textbox("PD"), sb_rudder = sliderbox(-500, 500, Pd, getForces_expr)),
	
			//hlistbox(textbox("Rotate Aircraft X"), sb_rotateACto_x = sliderbox(0,360,rotateACto_x_val,myscript)),
			//hlistbox(textbox("Rotate Aircraft Y"), sb_rotateACto_y = sliderbox(0,360,rotateACto_y_val,myscript)),
			//hlistbox(textbox("Rotate Aircraft Z"), sb_rotateACto_z = sliderbox(-180,180,rotateACto_z_val,myscript)),
		),
		/*graphbox("the graph box",
			Frame Size( 200, 200 ),
			xscale(-10,10),
			yscale(-10,10),
			markersize(5);
			dragmarker(x_coor, y_coor,
				//moveto_x_val = y_coor;
				rotateACto_x_val = -10*y_coor;
				//rotateto_x_val = rotateto_x_val;
				//centerpoint_z_val = -y_coor;
				//moveto_y_val = x_coor;
				rotateACto_z_val = 40*x_coor;
				//centerpoint_x_val = -x_coor;
				myscript;
			),	
		)*/
	)
);

ii=0;
draw_world = expr(
	scene << clear;
	makethebox_expr;
	drawtheairplane_expr;
	
	scene << Perspective( angleperspective, nearperspective, farperspective );
	scene << Translate( translateto_x_val, translateto_y_val, translatet  o_z_val );
	//scene <<Look At( /*eye*/ lookat_x_val,lookat_y_val,lookat_z_val, /*center*/ centerpoint_x_val,centerpoint_y_val,centerpoint_z_val, /*up*/ 0,0,1 );
	//scene << Color(0.1, .1, .1 );
	//scene << sphere(5,30,30);
	/*
	   scene  << Enable(Lighting); 
   scene  << Enable(Light0); 
   scene  << Light(Light0,AMBIENT,LightAmbient1,LightAmbient2,LightAmbient3,LightAmbient4);  
   scene  << Light(Light0,DIFFUSE,LightDiffuse1,LightDiffuse2,LightDiffuse3,LightDiffuse4);  
   scene  << Light(Light0,SPECULAR,LightSpecular1,LightSpecular2,LightSpecular3,LightSpecular4);  
   scene  << LightModel( LIGHT_MODEL_AMBIENT, LightModelAmbient1, LightModelAmbient2, LightModelAmbient3, LightModelAmbient4 );
   scene  << Material(Front,Ambient,MaterialAmbient1,MaterialAmbient2,MaterialAmbient3,MaterialAmbient4);
   scene  << Material(Front,Diffuse,MaterialDiffuse1,MaterialDiffuse2,MaterialDiffuse3,MaterialDiffuse4);
   scene  << Material(Front,Specular,MaterialSpecular1,MaterialSpecular2,MaterialSpecular3,MaterialSpecular4);
   scene  << Material(Front,Emission,MaterialEmission1,MaterialEmission2,MaterialEmission3,MaterialEmission4);
   scene  << Material(Front,Shininess,MaterialShininess);*/
	
	
	
	
	
	
	scene << pushmatrix;
	scene << Translate(0, 1, 7);
	scene << Rotate(-psi*180/3.14159+180, 0, 1, 0 );
	scene << Rotate(phi*180/3.14159, 0, 0, 1 );
	scene << Rotate(-theta*180/3.14159, 1, 0, 0 );
	scene << Color(1, .1, .1 );
	scene << Call list(plane);
	scene << popmatrix;
	//scene<<arcball(box,3);
	//scene << Translate( 1, 1, 1 );
	//scene << Call list(box);
	scene << Rotate(90, 1, 0, 0 );
	scene << Translate(-Pe, Pn, -Pd);
	scene << Rotate(rotateto_x_val, 1, 0, 0 );
	scene << Rotate(rotateto_y_val, 0, 1, 0 );
	scene << Rotate(rotateto_z_val, 0, 0, 1 );
	scene << Call list(box);
	scene << Color(0.1, .1, .1 );
	//scene << Call list(plane);
	//scene << Call list(box);
	//scene << arcball(plane,10);
	scene << Update;
);
initStates_expr;
draw_world;


ii=0;
show("hit for loop");
for(ii=1, ii<200000, ii++,
	lookat_y_val = 100-ii;
	moveto_y_val = 0 ;
	moveto_x_val = 0 ;
	//if (moveto_x_val < 5, moveto_x_val = 5;);
	moveto_z_val = 0;
	//centerpoint_y_val = centerpoint_y_val-ii;
	//centerpoint_y_val = -500;
	getForces_expr;
	updateState_expr; 
	draw_world;
	show(theta);
	wait(0.001);
);

